xquery version "3.1";

module namespace gen="http://teipublisher.com/generate";

declare namespace tei="http://www.tei-c.org/ns/1.0";
import module namespace idx="http://teipublisher.com/index" at "index.xql";
declare namespace xmldb="http://exist-db.org/xquery/xmldb";

(: target: the root of the bullinger data, e.g. /db/apps/bullinger-data :)
declare function gen:generate-all($target as xs:string) {
    gen:ensure-collection($target),
    gen:generate-navigation($target),
    gen:generate-localities-statistics($target)
    (: in the same fashion, we could generate a file with stats (e.g. sent and received
    count for persons) to speed up indexing :)
};

declare function gen:ensure-collection($target as xs:string) {
    if (not(exists(collection(concat($target, "/generated"))))) then
        xmldb:create-collection($target, "generated")
    else
        ()
};

(: Generate a file at $target/generated/navigation.xml with references for navigation between letters :)
declare function gen:generate-navigation($target as xs:string) {
    let $letters := for $letter in collection(concat($target, "/data/letters"))
        let $correspondents := distinct-values($letter//tei:correspAction/tei:persName/@ref/string())
        let $correspondentsString := string-join(for $a in $correspondents order by $a return $a, ',')
        let $dateElement := $letter//tei:correspAction[@type='sent']/tei:date
        let $date := idx:normalize-date(head(($dateElement/@when, $dateElement/@notAfter, $dateElement/@notBefore)))
        let $id := xs:integer(replace($letter/tei:TEI/@xml:id/string(), 'file', ''))
        order by $date, $id
        return map {
            "id": $id,
            "date": $date,
            "correspondents": $correspondentsString
        }

    let $groupedByCorrespondents := map:merge(
        for $letter in $letters
        group by $x := $letter?correspondents
        return map:entry($x, for $l in $letter order by $l?date return $l?id)
    )

    let $results := for $letter at $index in $letters
        let $id := $letter?id
        let $group := map:get($groupedByCorrespondents, $letter?correspondents)
        let $indexInGroup := index-of($group, $id)
        return map {
            "id": $id,
            "prev": if (exists($letters[$index - 1])) then $letters[$index - 1]?id else (),
            "next": if (exists($letters[$index + 1])) then $letters[$index + 1]?id else (),
            "prev-same-correspondents": $group[$indexInGroup - 1],
            "next-same-correspondents": $group[$indexInGroup + 1]
        }
    
    let $xmlResult :=
        <TEI xmlns="http://www.tei-c.org/ns/1.0">
            <teiHeader>
                <fileDesc>
                    <titleStmt>
                        <title>Pre-generated references for navigation</title>
                    </titleStmt>
                    <publicationStmt>
                        <p>Generated by post-install-generate.xql</p>
                    </publicationStmt>
                    <sourceDesc>
                        <p>Generated by post-install-generate.xql</p>
                    </sourceDesc>
                </fileDesc>
            </teiHeader>
            <standOff>
                <list type="letters">
                    {
                        for $result in $results
                        return 
                            <item xml:id="file{$result?id}">
                                {if ($result?prev) then <ptr type="prev" target="file{$result?prev}"/> else ()}
                                {if ($result?next) then <ptr type="next" target="file{$result?next}"/> else ()}
                                {if ($result?prev-same-correspondents) then <ptr type="prev-same-correspondents" target="file{$result?prev-same-correspondents}"/> else ()}
                                {if ($result?next-same-correspondents) then <ptr type="next-same-correspondents" target="file{$result?next-same-correspondents}"/> else ()}
                            </item>
                    }
                </list>
            </standOff>
        </TEI>
    
    return xmldb:store($target || "/generated", "navigation.xml", $xmlResult)
};

(: Generate a TEI-XML file with correspondence and mention counts per place :)
declare function gen:generate-localities-statistics($target as xs:string) {
    let $letters := collection(concat($target, "/data/letters"))

    let $placeMap :=
        let $allRefs :=
            for $letter in $letters
            let $id := $letter/tei:TEI/@xml:id/string()

            (: Collect places from <correspAction> only (to match case "place" in index.xql) :)
            let $correspRefs := distinct-values(
                $letter/tei:TEI/tei:teiHeader//tei:correspDesc//tei:correspAction/tei:placeName/@ref/string()
            )

            (: Collect places from whole document (to match case "mentioned-places" in index.xql) :)
            let $mentionRefs := distinct-values(
                $letter/tei:TEI//tei:placeName/@ref/string()
            )
            
            return
                for $ref in distinct-values(($correspRefs, $mentionRefs))
                return map {
                    "place": $ref,
                    "corresp": if ($ref = $correspRefs) then 1 else 0,
                    "mention": if ($ref = $mentionRefs) then 1 else 0
                }

        return
            fold-left(
                $allRefs,
                map {},
                function($acc as map(*), $entry as map(*)) as map(*) {
                    let $placeID := $entry?place
                    let $existing :=
                        if (map:contains($acc, $placeID))
                        then map:get($acc, $placeID)
                        else map { "corresp": 0, "mentions": 0 }

                    let $updated := map {
                        "corresp": $existing?corresp + $entry?corresp,
                        "mentions": $existing?mentions + $entry?mention
                    }

                    return map:put($acc, $placeID, $updated)
                }
            )

    let $items :=
        for $placeID in map:keys($placeMap)
        let $entry := $placeMap($placeID)
        order by $placeID
        return
            <item xml:id="{$placeID}">
                <measure type="corresp">{$entry?corresp}</measure>
                <measure type="mentions">{$entry?mentions}</measure>
            </item>

    let $xmlResult :=
        <TEI xmlns="http://www.tei-c.org/ns/1.0">
            <teiHeader>
                <fileDesc>
                    <titleStmt>
                        <title>Pre-generated locality statistics</title>
                    </titleStmt>
                    <publicationStmt>
                        <p>Generated by post-install-generate.xql</p>
                    </publicationStmt>
                    <sourceDesc>
                        <p>Generated by post-install-generate.xql</p>
                    </sourceDesc>
                </fileDesc>
            </teiHeader>
            <standOff>
                <list type="localities">
                   { $items }
                </list>
            </standOff>
        </TEI>

    return xmldb:store($target || "/generated", "localities-statistics.xml", $xmlResult)
};
